

from nipype.interfaces.fsl.model import MELODIC
import nipype.interfaces.utility    as util


from nipype.pipeline.engine import Workflow, Node
from nipype.interfaces import afni
from nipype.interfaces import fsl
from nipype.interfaces import ants



import os
pj = os.path.join



def parse_melodic_output(mel_dir,mask_file):
    """
    Do some smart stuff with the output from MELODIC.
    """
    
    # Import needed modules
    import os
    import subprocess
    
    #mel_dir = os.path.join(outDir, 'melodic.ica')
    melIC    = os.path.join(mel_dir, 'melodic_IC.nii.gz')
    melICmix = os.path.join(mel_dir, 'melodic_mix') # we will generate this
    melICthr = os.path.join(mel_dir, 'melodic_IC_thr.nii.gz') # we will generate this (FVV changed from outDir -> mel_dir)
    melftmix = os.path.join(mel_dir, 'melodic_FTmix') # will be generated by melodic

    # Get number of components
    cmd = ' '.join(['fslinfo',#os.path.join(fslDir, 'fslinfo'),
                    melIC,
                    '| grep dim4 | head -n1 | awk \'{print $2}\''])
    nrICs = int(float(subprocess.getoutput(cmd)))

    # Merge mixture modeled thresholded spatial maps. Note! In case that mixture modeling did not converge, the file will contain two spatial maps. The latter being the results from a simple null hypothesis test. In that case, this map will have to be used (first one will be empty).
    for i in range(1, nrICs + 1):
        # Define thresholded zstat-map file
        zTemp = os.path.join(mel_dir, 'stats', 'thresh_zstat' + str(i) + '.nii.gz')
        cmd = ' '.join(['fslinfo',#os.path.join(fslDir, 'fslinfo'),
                        zTemp,
                        '| grep dim4 | head -n1 | awk \'{print $2}\''])
        lenIC = int(float(subprocess.getoutput(cmd)))

        # Define zeropad for this IC-number and new zstat file
        cmd = ' '.join(['zeropad',#os.path.join(fslDir, 'zeropad'),
                        str(i),
                        '4'])
        ICnum = subprocess.getoutput(cmd)
        zstat = os.path.join(mel_dir, 'thr_zstat' + ICnum) # FVV changed outDir to mel_dir

        # Extract last spatial map within the thresh_zstat file
        os.system(' '.join(['fslroi', #os.path.join(fslDir, 'fslroi'),
                            zTemp,      # input
                            zstat,      # output
                            str(lenIC - 1),   # first frame
                            '1']))      # number of frames

    # Merge and subsequently remove all mixture modeled Z-maps within the output directory
    os.system(' '.join(['fslmerge',#os.path.join(fslDir, 'fslmerge'),
                        '-t',                       # concatenate in time
                        melICthr,                   # output
                        os.path.join(mel_dir, 'thr_zstat????.nii.gz')]))  # inputs  # FVV changed outDir to mel_dir

    os.system('rm ' + os.path.join(mel_dir, 'thr_zstat????.nii.gz'))  # FVV changed outDir to mel_dir

    # Apply the mask to the merged file (in case a melodic-directory was predefined and run with a different mask)
    os.system(' '.join(['fslmaths',#os.path.join(fslDir, 'fslmaths'),
                        melICthr,
                        '-mas ' + mask_file,
                        melICthr]))

    return melICmix,melICthr,nrICs,melftmix
    





def feature_spatial(melIC,numICs,aroma_csf_mask,aroma_edge_mask,aroma_out_mask):
    """ This function extracts the spatial feature scores. For each IC it determines the fraction of the mixture modeled thresholded Z-maps respecitvely located within the CSF or at the brain edges, using predefined standardized masks.

    Parameters
    ---------------------------------------------------------------------------------
    fslDir:     Full path of the bin-directory of FSL
    tempDir:    Full path of a directory where temporary files can be stored (called 'temp_IC.nii.gz')
    aromaDir:   Full path of the ICA-AROMA directory, containing the mask-files (mask_edge.nii.gz, mask_csf.nii.gz & mask_out.nii.gz) 
    melIC:      Full path of the nii.gz file containing mixture-modeled threholded (p>0.5) Z-maps, registered to the MNI152 2mm template
    melIC:      Number of MELODIC ICs

    Returns
    ---------------------------------------------------------------------------------
    edgeFract:  Array of the edge fraction feature scores for the components of the melIC file
    csfFract:   Array of the CSF fraction feature scores for the components of the melIC file"""

    # Import required modules
    import numpy as np
    import os
    import subprocess
    from past.utils import old_div

    tempDir = os.getcwd()
    
    # Get the number of ICs
    #numICs = int(subprocess.getoutput('fslinfo %s | grep dim4 | head -n1 | awk \'{print $2}\'' % (melIC) ))

    # Loop over ICs
    edgeFract = np.zeros(numICs)
    csfFract = np.zeros(numICs)
    for i in range(0, numICs):
        # Define temporary IC-file
        tempIC = os.path.join(tempDir, 'temp_IC.nii.gz')

        # Extract IC from the merged melodic_IC_thr2MNI2mm file
        os.system(' '.join(['fslroi', #os.path.join(, 'fslroi'),
                  melIC,
                  tempIC,
                  str(i),
                  '1']))

        # Change to absolute Z-values
        os.system(' '.join(['fslmaths', #os.path.join(fslDir, 'fslmaths'),
                  tempIC,
                  '-abs',
                  tempIC]))

        # Get sum of Z-values within the total Z-map (calculate via the mean and number of non-zero voxels)
        totVox = int(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                    tempIC,
                                                    '-V | awk \'{print $1}\''])))

        if not (totVox == 0):
            totMean = float(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                           tempIC,
                                                           '-M'])))
        else:
            print('     - The spatial map of component ' + str(i + 1) + ' is empty. Please check!')
            totMean = 0

        totSum = totMean * totVox

        # Get sum of Z-values of the voxels located within the CSF (calculate via the mean and number of non-zero voxels)
        csfVox = int(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                    tempIC,
                                                    '-k %s'%aroma_csf_mask, #AROMA_CSF_MASK_FILENAME, # mask_csf.nii.gz
                                                    '-V | awk \'{print $1}\''])))

        if not (csfVox == 0):
            csfMean = float(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                           tempIC,
                                                           '-k %s'%aroma_csf_mask, #mask_csf.nii.gz',
                                                           '-M'])))
        else:
            csfMean = 0

        csfSum = csfMean * csfVox

        # Get sum of Z-values of the voxels located within the Edge (calculate via the mean and number of non-zero voxels)
        edgeVox = int(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                     tempIC,
                                                     '-k %s'%aroma_edge_mask, # AROMA edge mask mask_edge.nii.gz',
                                                     '-V | awk \'{print $1}\''])))
        if not (edgeVox == 0):
            edgeMean = float(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                            tempIC,
                                                            '-k %s'%aroma_edge_mask, # AROMA edge mask mask_edge.nii.gz',
                                                            '-M'])))
        else:
            edgeMean = 0

        edgeSum = edgeMean * edgeVox

        # Get sum of Z-values of the voxels located outside the brain (calculate via the mean and number of non-zero voxels)
        outVox = int(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                    tempIC,
                                                    '-k %s'%aroma_out_mask,
                                                    '-V | awk \'{print $1}\''])))
        if not (outVox == 0):
            outMean = float(subprocess.getoutput(' '.join(['fslstats', #os.path.join(fslDir, 'fslstats'),
                                                           tempIC,
                                                           '-k %s'%aroma_out_mask,
                                                           '-M'])))
        else:
            outMean = 0

        outSum = outMean * outVox

        # Determine edge and CSF fraction
        if not (totSum == 0):
            edgeFract[i] = old_div((outSum + edgeSum), (totSum - csfSum))
            csfFract[i] = old_div(csfSum, totSum)
        else:
            edgeFract[i] = 0
            csfFract[i] = 0

    # Remove the temporary IC-file
    os.remove(tempIC)

    # Return feature scores
    return edgeFract, csfFract







def feature_time_series(melmix, mc):
    """ This function extracts the maximum RP correlation feature scores. It determines the maximum robust correlation of each component time-series with a model of 72 realigment parameters.

    Parameters
    ---------------------------------------------------------------------------------
    melmix:     Full path of the melodic_mix text file
    mc:     Full path of the text file containing the realignment parameters

    Returns
    ---------------------------------------------------------------------------------
    maxRPcorr:  Array of the maximum RP correlation feature scores for the components of the melodic_mix file"""

    # Import required modules
    import numpy as np
    import random

    # Read melodic mix file (IC time-series), subsequently define a set of squared time-series
    mix = np.loadtxt(melmix)
    mixsq = np.power(mix, 2)

    # Read motion parameter file
    RP6 = np.loadtxt(mc)

    # Determine the derivatives of the RPs (add zeros at time-point zero)
    RP6_der = np.array(RP6[list(range(1, RP6.shape[0])), :] - RP6[list(range(0, RP6.shape[0] - 1)), :])
    RP6_der = np.concatenate((np.zeros((1, 6)), RP6_der), axis=0)

    # Create an RP-model including the RPs and its derivatives
    RP12 = np.concatenate((RP6, RP6_der), axis=1)

    # Add the squared RP-terms to the model
    RP24 = np.concatenate((RP12, np.power(RP12, 2)), axis=1)

    # Derive shifted versions of the RP_model (1 frame for and backwards)
    RP24_1fw = np.concatenate((np.zeros((1, 24)), np.array(RP24[list(range(0, RP24.shape[0] - 1)), :])), axis=0)
    RP24_1bw = np.concatenate((np.array(RP24[list(range(1, RP24.shape[0])), :]), np.zeros((1, 24))), axis=0)

    # Combine the original and shifted mot_pars into a single model
    RP_model = np.concatenate((RP24, RP24_1fw, RP24_1bw), axis=1)

    # Define the column indices of respectively the squared or non-squared terms
    idx_nonsq = np.array(np.concatenate((list(range(0, 12)), list(range(24, 36)), list(range(48, 60))), axis=0))
    idx_sq = np.array(np.concatenate((list(range(12, 24)), list(range(36, 48)), list(range(60, 72))), axis=0))

    # Determine the maximum correlation between RPs and IC time-series
    nSplits = int(1000)
    maxTC = np.zeros((nSplits, mix.shape[1]))
    for i in range(0, nSplits):
        # Get a random set of 90% of the dataset and get associated RP model and IC time-series matrices
        idx = np.array(random.sample(list(range(0, mix.shape[0])), int(round(0.9 * mix.shape[0]))))
        RP_model_temp = RP_model[idx, :]
        mix_temp = mix[idx, :]
        mixsq_temp = mixsq[idx, :]

        # Calculate correlation between non-squared RP/IC time-series
        RP_model_nonsq = RP_model_temp[:, idx_nonsq]
        cor_nonsq = np.array(np.zeros((mix_temp.shape[1], RP_model_nonsq.shape[1])))
        for j in range(0, mix_temp.shape[1]):
            for k in range(0, RP_model_nonsq.shape[1]):
                cor_temp = np.corrcoef(mix_temp[:, j], RP_model_nonsq[:, k])
                cor_nonsq[j, k] = cor_temp[0, 1]

        # Calculate correlation between squared RP/IC time-series
        RP_model_sq = RP_model_temp[:, idx_sq]
        cor_sq = np.array(np.zeros((mix_temp.shape[1], RP_model_sq.shape[1])))
        for j in range(0, mixsq_temp.shape[1]):
            for k in range(0, RP_model_sq.shape[1]):
                cor_temp = np.corrcoef(mixsq_temp[:, j], RP_model_sq[:, k])
                cor_sq[j, k] = cor_temp[0, 1]

        # Combine the squared an non-squared correlation matrices
        corMatrix = np.concatenate((cor_sq, cor_nonsq), axis=1)

        # Get maximum absolute temporal correlation for every IC
        corMatrixAbs = np.abs(corMatrix)
        maxTC[i, :] = corMatrixAbs.max(axis=1)

    # Get the mean maximum correlation over all random splits
    # nanmean to deal with occasional nans popping up in the correlation calculation
    maxRPcorr = np.nanmean(maxTC, axis=0)

    # Return the feature score
    return maxRPcorr







def feature_frequency(melFTmix, TR):
    """ This function extracts the high-frequency content feature scores.
    It determines the frequency, as fraction of the Nyquist frequency,
    at which the higher and lower frequencies explain half
    of the total power between 0.01Hz and Nyquist.

    Parameters
    ---------------------------------------------------------------------------------
    melFTmix:   Full path of the melodic_FTmix text file
    TR:     TR (in seconds) of the fMRI data (float)

    Returns
    ---------------------------------------------------------------------------------
    HFC:        Array of the HFC ('High-frequency content') feature scores
    for the components of the melodic_FTmix file"""

    from past.utils import old_div
    
    # Import required modules
    import numpy as np

    # Determine sample frequency
    Fs = old_div(1, TR)

    # Determine Nyquist-frequency
    Ny = old_div(Fs, 2)

    # Load melodic_FTmix file
    FT = np.loadtxt(melFTmix)

    # Determine which frequencies are associated with every row in the melodic_FTmix file  (assuming the rows range from 0Hz to Nyquist)
    f = Ny * (np.array(list(range(1, FT.shape[0] + 1)))) / (FT.shape[0])

    # Only include frequencies higher than 0.01Hz
    fincl = np.squeeze(np.array(np.where(f > 0.01)))
    FT = FT[fincl, :]
    f = f[fincl]

    # Set frequency range to [0-1]
    f_norm = old_div((f - 0.01), (Ny - 0.01))

    # For every IC; get the cumulative sum as a fraction of the total sum
    fcumsum_fract = old_div(np.cumsum(FT, axis=0), np.sum(FT, axis=0))

    # Determine the index of the frequency with the fractional cumulative sum closest to 0.5
    idx_cutoff = np.argmin(np.abs(fcumsum_fract - 0.5), axis=0)

    # Now get the fractions associated with those indices index, these are the final feature scores
    HFC = f_norm[idx_cutoff]

    # Return feature score
    return HFC




def classification(maxRPcorr, edgeFract, HFC, csfFract):
    """ This function classifies a set of components into motion and 
    non-motion components based on four features; 
    maximum RP correlation, high-frequency content, edge-fraction and CSF-fraction

    Parameters
    ---------------------------------------------------------------------------------
    outDir:     Full path of the output directory
    maxRPcorr:  Array of the 'maximum RP correlation' feature scores of the components
    edgeFract:  Array of the 'edge fraction' feature scores of the components
    HFC:        Array of the 'high-frequency content' feature scores of the components
    csfFract:   Array of the 'CSF fraction' feature scores of the components

    Return
    ---------------------------------------------------------------------------------
    motionICs   Array containing the indices of the components identified as motion components

    Output (within the requested output directory)
    ---------------------------------------------------------------------------------
    classified_motion_ICs.txt   A text file containing the indices of the components identified as motion components """

    # Import required modules
    import numpy as np
    import os

    outDir = os.getcwd()

    # Classify the ICs as motion or non-motion

    # Define criteria needed for classification (thresholds and hyperplane-parameters)
    thr_csf = 0.10
    thr_HFC = 0.35
    hyp = np.array([-19.9751070082159, 9.95127547670627, 24.8333160239175])

    # Project edge & maxRPcorr feature scores to new 1D space
    x = np.array([maxRPcorr, edgeFract])
    proj = hyp[0] + np.dot(x.T, hyp[1:])

    # Classify the ICs
    motionICs = np.squeeze(np.array(np.where((proj > 0) + (csfFract > thr_csf) + (HFC > thr_HFC))))

    # Put the feature scores in a text file
    np.savetxt(os.path.join(outDir, 'feature_scores.txt'), np.vstack((maxRPcorr, edgeFract, HFC, csfFract)).T)

    # Put the indices of motion-classified ICs in a text file
    txt = open(os.path.join(outDir, 'classified_motion_ICs.txt'), 'w')
    if motionICs.size > 1:  # and len(motionICs) != 0: if motionICs is not None and 
        txt.write(','.join(['%.0f' % num for num in (motionICs + 1)]))
    elif motionICs.size == 1:
        txt.write('%.0f' % (motionICs + 1))
    txt.close()

    # Create a summary overview of the classification
    txt = open(os.path.join(outDir, 'classification_overview.txt'), 'w')
    txt.write('IC' + '\t' + 'Motion/noise' + '\t' + 'maximum RP correlation' + '\t' + 'Edge-fraction' + '\t\t' + 'High-frequency content' + '\t' + 'CSF-fraction')
    txt.write('\n')
    for i in range(0, len(csfFract)):
        if (proj[i] > 0) or (csfFract[i] > thr_csf) or (HFC[i] > thr_HFC):
            classif = "True"
        else:
            classif = "False"
        txt.write('%.0f\t%s\t\t%.2f\t\t\t%.2f\t\t\t%.2f\t\t\t%.2f\n' % (i + 1, classif, maxRPcorr[i], edgeFract[i], HFC[i], csfFract[i]))
    txt.close()

    return motionICs







def denoising(inFile, melmix, denType, denIdx):
    """ 

    Parameters
    ---------------------------------------------------------------------------------
    fslDir:     Full path of the bin-directory of FSL
    inFile:     Full path to the data file (nii.gz) which has to be denoised
    outDir:     Full path of the output directory
    melmix:     Full path of the melodic_mix text file
    denType:    Type of requested denoising ('aggr': aggressive, 'nonaggr': non-aggressive, 'both': both aggressive and non-aggressive 
    denIdx:     Indices of the components that should be regressed out

    Output (within the requested output directory)
    ---------------------------------------------------------------------------------
    denoised_func_data_<denType>.nii.gz:        A nii.gz file of the denoised fMRI data"""

    # Import required modules
    import os
    import numpy as np

    outDir = os.getcwd()

    # Check if denoising is needed (i.e. are there components classified as motion)
    check = denIdx.size > 0

    out_files = []
    
    if check == 1:
        # Put IC indices into a char array
        if denIdx.size == 1:
            denIdxStrJoin = "%d"%(denIdx + 1)
        else:
            denIdxStr = np.char.mod('%i', (denIdx + 1))
            denIdxStrJoin = ','.join(denIdxStr)

        # Non-aggressive denoising of the data using fsl_regfilt (partial regression), if requested
        if (denType == 'nonaggr') or (denType == 'both'):
            outf = os.path.join(outDir, 'denoised_func_data_nonaggr.nii.gz')
            os.system(' '.join(['fsl_regfilt', #os.path.join(fslDir, 'fsl_regfilt'),
                                '--in=' + inFile,
                                '--design=' + melmix,
                                '--filter="' + denIdxStrJoin + '"',
                                '--out=' + outf]))
            out_files.append(outf)
        # Aggressive denoising of the data using fsl_regfilt (full regression)
        if (denType == 'aggr') or (denType == 'both'):
            outf = os.path.join(outDir, 'denoised_func_data_aggr.nii.gz')
            os.system(' '.join(['fsl_regfilt', #os.path.join(fslDir, 'fsl_regfilt'),
                                '--in=' + inFile,
                                '--design=' + melmix,
                                '--filter="' + denIdxStrJoin + '"',
                                '--out=' + outf,
                                '-a']))
            out_files.append(outf)
    else:
        print("  - None of the components were classified as motion, so no denoising is applied (a symbolic link to the input file will be created).")
        if (denType == 'nonaggr') or (denType == 'both'):
            outf = os.path.join(outDir, 'denoised_func_data_nonaggr.nii.gz')
            os.symlink(inFile, outf)
            out_files.append(outf)
        if (denType == 'aggr') or (denType == 'both'):
            outf = os.path.join(outDir, 'denoised_func_data_aggr.nii.gz')
            os.symlink(inFile, outf)
            out_files.append(outf)

    return out_files




def ica_aroma_report(nICs,
                     motionICs,
                     HFC,
                     csfFract,
                     edgeFract,
                     maxRPcorr,
):
    """ Generates a report from ICA_AROMA for human inspection.

    Arguments
    nICs       : number of ICs
    motionICs  : ids of ICs classified as motion by ICA AROMA
    
    HFC        : 

    """

    import pandas as pd
    import os
    ics = range(nICs)
    tab = pd.DataFrame({
        "IC"                      :ics,
        "HFC"                     :HFC,
        "csfFract"                :csfFract,
        "edgeFract"               :edgeFract,
        "maxRPcorr"               :maxRPcorr,
        "ICA_AROMA_classification":[ ic in motionICs for ic in ics]
        })
    fname = 'ica_aroma_classification.csv'
    tab.to_csv(fname)
    return os.path.abspath(fname)






def motion_sixonly(motreg_file):
    """
    Ensure that the motion regressors file has only 6 entries (the six canonical motion parameters).
    This is done because often we have also included their regressors.
    """
    import os
    import numpy as np
    motion_regressor=np.genfromtxt(motreg_file)
    # Grab only the first six columns.
    onlysix = motion_regressor[:,:6]
    fname = 'motion_regressors_onlysix.txt'
    np.savetxt(fname,onlysix)
    return os.path.abspath(fname)











def create_ica_aroma_workflow(
        N_TRANSFORMS # number of transformations that take you from func space to MNI
):

    # Stuff that relates to your installation
    #TEMPLATE_MNI2MM   = '/usr/share/data/fsl-mni152-templates/MNI152_T1_2mm.nii.gz'
    TEMPLATE_MNI2MM   = '/usr/local/fsl/data/standard/MNI152_T1_2mm.nii.gz'
    AROMA_INSTALL_DIR =  "/brains/audiomotor.mrs.nipype/misc/ICA-AROMA" # where you installed AROMA (will be used to pull mask_XXX.nii.gz files)


 
    wf = Workflow(name='ICA_AROMA')


    incoming = Node(interface=util.IdentityInterface(
        fields=['in_file',      # input functional time series; motion corrected and smoothed but NOT filtered
                'sample_func',  # a sample func from which the mask file will be generated
                'melodic_dir',  # directory where we will put melodic files
                'motion_par',   # motion parameters
                'tr',           # in seconds
                'func2mni_transf', # (set of) transformations that bring us from func space to mni space (need to be in order for antsApplyTransforms)
                'denoise_type', # what kind of denoising to apply  ('aggr': aggressive, 'nonaggr': non-aggressive, 'both': both aggressive and non-aggressive )
        ]),
                    name="incoming")

    outgoing = Node(interface=util.IdentityInterface(
        fields=['denoised_file',  # output denoised
                'motionICs',      # motion ICs
                'mask_file',      # mask file used when running MELODIC
                'aroma_report',   # a table with the ICA_AROMA ICs and their classification details
        ]),
                    name="outgoing")



    #
    # Prepare the motion file, to ensure it has only six entries
    #
    motionprep = Node(util.Function(input_names=['motreg_file'],
                                    output_names=['six_motion_file'],
                                    function=motion_sixonly),
                       name='motion_regressors_sixonly')
    wf.connect(incoming,'motion_par',motionprep,'motreg_file')
    


    
    #
    #
    # Prepare the mask
    #
    #
    bet = Node(interface=fsl.BET(),name='fsl_bet') # ICA_AROMA manual suggests bet -f .3 -n -m -R
    bet.inputs.frac       = .3
    bet.inputs.mask       = True  # -m 
    bet.inputs.no_output  = True # -n
    bet.inputs.robust     = True # -R
    wf.connect(incoming,'sample_func',bet,'in_file')
    wf.connect(bet,'mask_file',outgoing,'mask_file')



    #
    #
    # Run ICA
    #
    #

    melodic = Node(interface=MELODIC(),name='melodic')

    wf.connect(incoming,'in_file',melodic,'in_files')
    #wf.connect(incoming, 'in_file', melodic, 'in_files')
    wf.connect(bet,     'mask_file', melodic, 'mask') 
    #wf.connect(incoming, 'mask_file', melodic, 'mask_file')
    wf.connect(incoming,'melodic_dir',melodic,'out_dir')

    melodic.inputs.dim        = 0
    melodic.inputs.out_stats  = True
    melodic.inputs.no_bet     = True
    melodic.inputs.mm_thresh  = .5
    melodic.inputs.report     = False # True


    ## Now we grab the files we need from the melodic output directory
    ## and perform the merging and thresholding.
    parsemelout = Node(util.Function(input_names=['mel_dir','mask_file'],
                                     output_names=['mel_IC_mix',
                                                   'mel_IC_tresh',
                                                   'n_IC', # number of components
                                                   'melftmix' # melodic_FTmix file name full path
                                     ],
                                     function=parse_melodic_output),
                       name='parse_melodic_output')
    wf.connect(bet,    'mask_file',parsemelout,'mask_file')
    wf.connect(melodic,'out_dir',  parsemelout,'mel_dir')




    #
    #
    # Register components to MNI152 2mm
    #
    #


    # This could perhaps be fed into the workflow when we incorporate it
    #translist = Node(util.Merge(N_TRANSFORMS),
    #                 name='transf_list')
    #translist.inputs.in4 = os.path.abspath('sdc/out_warp/warpfield.nii.gz')                   # epi SDC unwarping
    #translist.inputs.in3 = os.path.abspath('epi2anat/epi2anat_lin.txt')                       # epi2anat
    #translist.inputs.in2 = os.path.abspath('anat/transforms2mni/transform0GenericAffine.mat') # anat2std part 1
    #translist.inputs.in1 = os.path.abspath('anat/transforms2mni/transform1Warp.nii.gz')       # anat2std part 2
    # Note that in1..in4 are order-inversed here, so in4 will be applied first, then in3, etc. etc.
    # (this is the default for ants.applytransforms)
    


    # apply all transforms
    f2mni = Node(ants.ApplyTransforms(input_image_type = 3,
                                      output_image='IC_transf.nii.gz',
                                      interpolation = 'BSpline',
                                      invert_transform_flags=[False]*N_TRANSFORMS),
                 name='func2mni')
    #f2mni.plugin_args={'submit_specs': 'request_memory = 30000'}
    f2mni.inputs.reference_image = TEMPLATE_MNI2MM
    # Warp this into MNI space
    wf.connect( incoming, 'func2mni_transf', f2mni, 'transforms' )
    wf.connect( parsemelout, 'mel_IC_tresh', f2mni, 'input_image') #parsemelout.outputs.mel_IC_thresh
    #wf.connect( denoise,   'denoised_file', func2mni, 'input_image' )
    #wf.connect( translist, 'out',           f2mni, 'transforms' )
    

    # f2mni.output_image is melodic_IC_thr transformed to 2mm MNI space




    #
    #
    #  Extracting features, classifying ...
    #
    #




    ## Extracting the CSF & Edge fraction features')

    feature_spat = Node(util.Function(input_names=['melIC',# MNI-registered file with components
                                                   'numICs', # number of ICs
                                                   'aroma_csf_mask',   # AROMA CSF mask (mask_csf.nii.gz distributed with ICA_AROMA)
                                                   'aroma_edge_mask',  # AROMA edge mask (mask_edge.nii.gz distributed with ICA_AROMA)
                                                   'aroma_out_mask',   # AROMA out mask (mask_out.nii.gz distributed with ICA_AROMA)

    ],
                                      output_names=['edgeFract',
                                                    'csfFract'],
                                      function=feature_spatial),
                        name='feature_spatial')

    feature_spat.inputs.aroma_csf_mask  = pj(AROMA_INSTALL_DIR,"mask_csf.nii.gz")
    feature_spat.inputs.aroma_edge_mask = pj(AROMA_INSTALL_DIR,"mask_edge.nii.gz")
    feature_spat.inputs.aroma_out_mask  = pj(AROMA_INSTALL_DIR,"mask_out.nii.gz")


    wf.connect( parsemelout,'n_IC',      feature_spat,'numICs')
    wf.connect( f2mni, 'output_image',   feature_spat,'melIC')




    ## Extracting the Maximum RP correlation feature')
    feature_ts = Node(util.Function(input_names=['melmix',# full path to melodic_mix text file
                                                 'mc',    # file containing motion parameters
    ],
                                    output_names=['maxRPcorr'], # Array of the maximum RP correlation feature scores for the components of the melodic_mix file
                                    function=feature_time_series),
                      name='feature_time_series')

    wf.connect( parsemelout,'mel_IC_mix',      feature_ts,'melmix')
    wf.connect( motionprep, 'six_motion_file', feature_ts, 'mc')




    ## Extracting the High-frequency content feature')
    feature_freq = Node(util.Function(input_names=['melFTmix',# ... will be generated?
                                                   'TR',    # repetition time (TR)
    ],
                                      output_names=['HFC'], #Array of the HFC ('High-frequency content') feature scores for the components of the melodic_FTmix file
                                      function=feature_frequency),
                        name='feature_frequency')

    wf.connect( parsemelout,'melftmix',feature_freq,'melFTmix')
    wf.connect( incoming,   'tr',      feature_freq,'TR')



    ## Classification
    classif = Node(util.Function(input_names=['maxRPcorr',
                                              'edgeFract',
                                              'HFC',
                                              'csfFract'],
                                 output_names=['motionICs'],# Array containing the indices of the components identified as motion components
                                 function=classification),
                   name='classification')

    wf.connect( feature_ts,   'maxRPcorr', classif,'maxRPcorr')
    wf.connect( feature_spat, 'edgeFract', classif,'edgeFract')
    wf.connect( feature_spat, 'csfFract',  classif,'csfFract')
    wf.connect( feature_freq, 'HFC',       classif,'HFC')




    ## Denoising -- go back to the original image and denoise
    denoiz = Node(util.Function(input_names=['inFile',
                                             'melmix',
                                             'denType',
                                             'denIdx'],
                                output_names=['denoised_file'],# Array containing the indices of the components identified as motion components
                                function=denoising),
                  name='denoising')

    wf.connect( incoming,    'denoise_type', denoiz, 'denType')
    wf.connect( incoming,    'in_file',      denoiz, 'inFile')
    wf.connect( parsemelout, 'mel_IC_mix'   ,denoiz, 'melmix')
    wf.connect( classif,     'motionICs',    denoiz, 'denIdx')

    wf.connect( denoiz, 'denoised_file', outgoing, 'denoised_file')
    wf.connect( classif, 'motionICs',    outgoing, 'motionICs')


    ## Make a table that lists the features and classification result
    maketab = Node(util.Function(input_names=['nICs','motionICs','HFC','csfFract','edgeFract','maxRPcorr'],
                                 output_names=['ica_aroma_report_file'],
                                 function=ica_aroma_report),
                   name='aroma_report')
    wf.connect( parsemelout,  'n_IC',      maketab, 'nICs' )
    wf.connect( classif,      'motionICs', maketab, 'motionICs' )
    wf.connect( feature_freq, 'HFC',       maketab,'HFC' )
    wf.connect( feature_ts,   'maxRPcorr', maketab,'maxRPcorr')
    wf.connect( feature_spat, 'edgeFract', maketab,'edgeFract')
    wf.connect( feature_spat, 'csfFract',  maketab,'csfFract')
    wf.connect( maketab,      'ica_aroma_report_file', outgoing, 'aroma_report')
    
    return wf

